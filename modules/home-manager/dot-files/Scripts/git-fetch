#!/usr/bin/env bash

# determine current branch name
current_branch=$(git symbolic-ref --short HEAD)

# initialize
remote=""
branch=""
opts=()

# upstream only if upstream remote present AND resolved branch will be main
get_default_remote() {
  local resolved_branch="$1"
  if git remote | grep -q upstream && [[ "$resolved_branch" == "main" ]]; then
    echo "upstream"
  else
    echo "origin"
  fi
}

# no arguments → default_remote + current branch
if [[ $# -eq 0 ]]; then
  branch="$current_branch"
  remote=$(get_default_remote "$branch")

# first arg is an option → default_remote + current branch + pass all args through
elif [[ "$1" == -* ]]; then
  branch="$current_branch"
  remote=$(get_default_remote "$branch")
  opts=("$@")

# otherwise we have at least one positional
else
  arg1="$1"; shift
  # if next token exists and is not an option, treat as remote+branch
  if [[ $# -gt 0 && "$1" != -* ]]; then
    arg2="$1"; shift
    remote="$arg1"
    branch="$arg2"
    opts=("$@")
  # otherwise treat the one positional as branch (remote defaults to default_remote)
  else
    branch="$arg1"
    remote=$(get_default_remote "$branch")
    opts=("$@")
  fi
fi

# build the command array
cmd=(git fetch "$remote" "$branch" "${opts[@]}")

echo "${cmd[@]}"
"${cmd[@]}"
